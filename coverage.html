
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>copier: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/sakuhanight/gopier/internal/copier/copier.go (49.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package copier

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/sakuhanight/gopier/internal/database"
        "github.com/sakuhanight/gopier/internal/filter"
        "github.com/sakuhanight/gopier/internal/hasher"
        "github.com/sakuhanight/gopier/internal/logger"
        "github.com/sakuhanight/gopier/internal/stats"
)

// CopyMode はコピーモードを表す型
type CopyMode int

const (
        // ModeCopy は通常のコピーモード
        ModeCopy CopyMode = iota
        // ModeVerify は検証のみのモード
        ModeVerify
        // ModeCopyAndVerify はコピーと検証を行うモード
        ModeCopyAndVerify
)

// ProgressCallback は進捗報告のためのコールバック関数型
type ProgressCallback func(current, total int64, currentFile string)

// Options はコピーオプションを表す構造体
type Options struct {
        BufferSize        int           // コピーバッファサイズ
        Recursive         bool          // 再帰的にコピーするかどうか
        PreserveModTime   bool          // 更新日時を保持するかどうか
        VerifyHash        bool          // ハッシュ検証を行うかどうか
        HashAlgorithm     string        // ハッシュアルゴリズム
        OverwriteExisting bool          // 既存ファイルを上書きするかどうか
        CreateDirs        bool          // 必要なディレクトリを作成するかどうか
        MaxRetries        int           // 最大再試行回数
        RetryDelay        time.Duration // 再試行の遅延時間
        ProgressInterval  time.Duration // 進捗報告の間隔
        MaxConcurrent     int           // 最大並行コピー数
        Mode              CopyMode      // コピーモード
}

// DefaultOptions はデフォルトのオプションを返す
func DefaultOptions() Options <span class="cov8" title="1">{
        return Options{
                BufferSize:        32 * 1024 * 1024, // 32MB
                Recursive:         true,
                PreserveModTime:   true,
                VerifyHash:        true,
                HashAlgorithm:     string(hasher.SHA256),
                OverwriteExisting: true,
                CreateDirs:        true,
                MaxRetries:        3,
                RetryDelay:        time.Second * 2,
                ProgressInterval:  time.Second * 1,
                MaxConcurrent:     4,
                Mode:              ModeCopy,
        }
}</span>

// FileCopier はファイルコピー処理を管理する構造体
type FileCopier struct {
        sourceDir    string
        destDir      string
        options      Options
        stats        *stats.Stats
        filter       *filter.Filter
        hasher       *hasher.Hasher
        db           *database.SyncDB
        logger       *logger.Logger
        progressChan chan string
        progressFunc ProgressCallback
        wg           sync.WaitGroup
        semaphore    chan struct{}
        ctx          context.Context
        cancel       context.CancelFunc
}

// NewFileCopier は新しいFileCopierを作成する
func NewFileCopier(sourceDir, destDir string, options Options, fileFilter *filter.Filter, syncDB *database.SyncDB, log *logger.Logger) *FileCopier <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        // セマフォの初期化
        semaphore := make(chan struct{}, options.MaxConcurrent)

        // ハッシャーの初期化
        hashAlgo := hasher.Algorithm(options.HashAlgorithm)
        fileHasher := hasher.NewHasher(hashAlgo, options.BufferSize)

        return &amp;FileCopier{
                sourceDir:    sourceDir,
                destDir:      destDir,
                options:      options,
                stats:        stats.NewStats(),
                filter:       fileFilter,
                hasher:       fileHasher,
                db:           syncDB,
                logger:       log,
                progressChan: make(chan string, 100),
                ctx:          ctx,
                cancel:       cancel,
                semaphore:    semaphore,
        }
}</span>

// SetProgressCallback は進捗報告のコールバック関数を設定する
func (fc *FileCopier) SetProgressCallback(callback ProgressCallback) <span class="cov8" title="1">{
        fc.progressFunc = callback
}</span>

// GetStats は現在の統計情報を返す
func (fc *FileCopier) GetStats() *stats.Stats <span class="cov8" title="1">{
        return fc.stats
}</span>

// Cancel はコピー処理をキャンセルする
func (fc *FileCopier) Cancel() <span class="cov8" title="1">{
        fc.cancel()
}</span>

// CopyFiles はファイルをコピーする
func (fc *FileCopier) CopyFiles() error <span class="cov8" title="1">{
        // 同期セッションの開始
        var sessionID int64
        var err error
        if fc.db != nil </span><span class="cov8" title="1">{
                sessionID, err = fc.db.StartSyncSession()
                if err != nil </span><span class="cov0" title="0">{
                        // loggerでエラー出力
                        if fc.logger != nil </span><span class="cov0" title="0">{
                                if fc.logger.Verbose </span><span class="cov0" title="0">{
                                        fc.logger.Error("同期セッション開始エラー: %v", err)
                                }</span> else<span class="cov0" title="0"> {
                                        fc.logger.Error("セッション開始失敗")
                                }</span>
                        }
                        <span class="cov0" title="0">return fmt.Errorf("同期セッション開始エラー: %w", err)</span>
                }
        }

        // 進捗報告ゴルーチンの開始
        <span class="cov8" title="1">if fc.progressFunc != nil </span><span class="cov8" title="1">{
                go fc.reportProgress()
        }</span>

        // ソースディレクトリの存在確認
        <span class="cov8" title="1">sourceInfo, err := os.Stat(fc.sourceDir)
        if err != nil </span><span class="cov8" title="1">{
                // loggerでエラー出力
                if fc.logger != nil </span><span class="cov0" title="0">{
                        if fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Error("ソースディレクトリ(%s)の確認エラー: %v", fc.sourceDir, err)
                        }</span> else<span class="cov0" title="0"> {
                                fc.logger.Error("ソースディレクトリ確認失敗")
                        }</span>
                }
                <span class="cov8" title="1">fc.stats.IncrementFailed()
                return fmt.Errorf("ソースディレクトリ(%s)の確認エラー: %w", fc.sourceDir, err)</span>
        }

        // ソースがディレクトリの場合
        <span class="cov8" title="1">if sourceInfo.IsDir() </span><span class="cov8" title="1">{
                // 宛先ディレクトリの作成
                if fc.options.CreateDirs </span><span class="cov8" title="1">{
                        if err := os.MkdirAll(fc.destDir, 0755); err != nil </span><span class="cov0" title="0">{
                                // loggerでエラー出力
                                if fc.logger != nil </span><span class="cov0" title="0">{
                                        if fc.logger.Verbose </span><span class="cov0" title="0">{
                                                fc.logger.Error("宛先ディレクトリ(%s)の作成エラー: %v", fc.destDir, err)
                                        }</span> else<span class="cov0" title="0"> {
                                                fc.logger.Error("宛先ディレクトリ作成失敗")
                                        }</span>
                                }
                                <span class="cov0" title="0">return fmt.Errorf("宛先ディレクトリ(%s)の作成エラー: %w", fc.destDir, err)</span>
                        }
                }

                // loggerで開始情報を出力
                <span class="cov8" title="1">if fc.logger != nil </span><span class="cov0" title="0">{
                        if fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Info("ディレクトリコピー開始: %s -&gt; %s", fc.sourceDir, fc.destDir)
                        }</span> else<span class="cov0" title="0"> {
                                fc.logger.Info("ディレクトリコピー開始")
                        }</span>
                }

                // ディレクトリのコピー
                <span class="cov8" title="1">err = fc.copyDirectory(fc.sourceDir, fc.destDir)</span>
        } else<span class="cov8" title="1"> {
                // 単一ファイルのコピー
                destPath := filepath.Join(fc.destDir, filepath.Base(fc.sourceDir))

                // loggerで開始情報を出力
                if fc.logger != nil </span><span class="cov0" title="0">{
                        if fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Info("ファイルコピー開始: %s -&gt; %s", fc.sourceDir, destPath)
                        }</span> else<span class="cov0" title="0"> {
                                fc.logger.Info("ファイルコピー開始")
                        }</span>
                }

                <span class="cov8" title="1">err = fc.copyFile(fc.sourceDir, destPath)</span>
        }

        // すべてのゴルーチンの完了を待つ
        <span class="cov8" title="1">fc.wg.Wait()

        // チャンネルがまだ開いている場合のみ閉じる
        select </span>{
        case &lt;-fc.progressChan:<span class="cov0" title="0"></span>
                // チャンネルは既に閉じられている
        default:<span class="cov8" title="1">
                close(fc.progressChan)</span>
        }

        // 同期セッションの終了
        <span class="cov8" title="1">if fc.db != nil </span><span class="cov8" title="1">{
                endErr := fc.db.EndSyncSession(
                        sessionID,
                        int(fc.stats.GetCopiedCount()),
                        int(fc.stats.GetSkippedCount()),
                        int(fc.stats.GetFailedCount()),
                        fc.stats.GetCopiedBytes(),
                )
                if endErr != nil </span><span class="cov0" title="0">{
                        // セッション終了エラーはログに記録するが、元のエラーを返す
                        if fc.logger != nil </span><span class="cov0" title="0">{
                                if fc.logger.Verbose </span><span class="cov0" title="0">{
                                        fc.logger.Warn("同期セッション終了エラー: %v", endErr)
                                }</span> else<span class="cov0" title="0"> {
                                        fc.logger.Warn("セッション終了エラー")
                                }</span>
                        }
                }
        }

        // 完了情報を出力
        <span class="cov8" title="1">if fc.logger != nil </span><span class="cov0" title="0">{
                copiedCount := fc.stats.GetCopiedCount()
                skippedCount := fc.stats.GetSkippedCount()
                failedCount := fc.stats.GetFailedCount()
                copiedBytes := fc.stats.GetCopiedBytes()

                if fc.logger.Verbose </span><span class="cov0" title="0">{
                        fc.logger.Info("コピー完了: コピー=%d, スキップ=%d, 失敗=%d, バイト=%d",
                                copiedCount, skippedCount, failedCount, copiedBytes)
                }</span> else<span class="cov0" title="0"> {
                        fc.logger.Info("コピー完了: %dファイル", copiedCount+skippedCount+failedCount)
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

// copyDirectory はディレクトリを再帰的にコピーする
func (fc *FileCopier) copyDirectory(sourceDir, destDir string) error <span class="cov8" title="1">{
        // コンテキストのキャンセル確認
        select </span>{
        case &lt;-fc.ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("コピー処理がキャンセルされました")</span>
        default:<span class="cov8" title="1"></span>
        }

        // ソースディレクトリを開く
        <span class="cov8" title="1">entries, err := os.ReadDir(sourceDir)
        if err != nil </span><span class="cov8" title="1">{
                // loggerでエラー出力
                if fc.logger != nil &amp;&amp; fc.logger.Verbose </span><span class="cov0" title="0">{
                        fc.logger.Error("ディレクトリ(%s)の読み込みエラー: %v", sourceDir, err)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("ディレクトリ(%s)の読み込みエラー: %w", sourceDir, err)</span>
        }

        // 宛先ディレクトリの作成
        <span class="cov8" title="1">if fc.options.CreateDirs </span><span class="cov8" title="1">{
                if err := os.MkdirAll(destDir, 0755); err != nil </span><span class="cov0" title="0">{
                        // loggerでエラー出力
                        if fc.logger != nil &amp;&amp; fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Error("宛先ディレクトリ(%s)の作成エラー: %v", destDir, err)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("宛先ディレクトリ(%s)の作成エラー: %w", destDir, err)</span>
                }
        }

        // 各エントリの処理
        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                sourcePath := filepath.Join(sourceDir, entry.Name())
                destPath := filepath.Join(destDir, entry.Name())

                // ディレクトリの場合
                if entry.IsDir() </span><span class="cov8" title="1">{
                        if !fc.options.Recursive </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // 再帰的にコピー
                        <span class="cov8" title="1">if err := fc.copyDirectory(sourcePath, destPath); err != nil </span><span class="cov0" title="0">{
                                // loggerでエラー出力
                                if fc.logger != nil &amp;&amp; fc.logger.Verbose </span><span class="cov0" title="0">{
                                        fc.logger.Error("サブディレクトリ(%s)のコピーエラー: %v", sourcePath, err)
                                }</span>
                                <span class="cov0" title="0">return err</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }

                // ファイルの場合
                <span class="cov8" title="1">info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        fc.stats.IncrementFailed()

                        // loggerでエラー出力
                        if fc.logger != nil &amp;&amp; fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Error("ファイル情報取得エラー: %s: %v", sourcePath, err)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("ファイル情報取得エラー: %w", err)</span>
                }

                // フィルタリング
                <span class="cov8" title="1">if fc.filter != nil &amp;&amp; !fc.filter.ShouldInclude(sourcePath) </span><span class="cov8" title="1">{
                        // ファイルをスキップ
                        fc.stats.IncrementSkipped(info.Size())

                        // データベースに記録
                        if fc.db != nil </span><span class="cov0" title="0">{
                                relPath, _ := filepath.Rel(fc.sourceDir, sourcePath)
                                fileInfo := database.FileInfo{
                                        Path:         relPath,
                                        Size:         info.Size(),
                                        ModTime:      info.ModTime(),
                                        Status:       database.StatusSkipped,
                                        LastSyncTime: time.Now(),
                                        LastError:    "フィルタによりスキップ",
                                }
                                fc.db.AddFile(fileInfo)
                        }</span>

                        // loggerでスキップ情報を出力
                        <span class="cov8" title="1">if fc.logger != nil &amp;&amp; fc.logger.Verbose </span><span class="cov0" title="0">{
                                relPath, _ := filepath.Rel(fc.sourceDir, sourcePath)
                                fc.logger.Info("ファイルをスキップ（フィルタ）: %s", relPath)
                        }</span>

                        <span class="cov8" title="1">continue</span>
                }

                // 非同期でファイルをコピー
                <span class="cov8" title="1">fc.wg.Add(1)
                go func(src, dst string) </span><span class="cov8" title="1">{
                        defer fc.wg.Done()

                        // セマフォの取得
                        fc.semaphore &lt;- struct{}{}
                        defer func() </span><span class="cov8" title="1">{
                                &lt;-fc.semaphore
                        }</span>()

                        <span class="cov8" title="1">if err := fc.copyFile(src, dst); err != nil </span><span class="cov8" title="1">{
                                // loggerでエラー出力（非同期処理なので詳細は出力しない）
                                if fc.logger != nil </span><span class="cov0" title="0">{
                                        relPath, _ := filepath.Rel(fc.sourceDir, src)
                                        fc.logger.Error("ファイルコピーエラー: %s", relPath)
                                }</span>
                        }
                }(sourcePath, destPath)
        }

        <span class="cov8" title="1">return nil</span>
}

// copyFile は単一ファイルをコピーする
func (fc *FileCopier) copyFile(sourcePath, destPath string) error <span class="cov8" title="1">{
        // コンテキストのキャンセル確認
        select </span>{
        case &lt;-fc.ctx.Done():<span class="cov0" title="0">
                return fmt.Errorf("コピー処理がキャンセルされました")</span>
        default:<span class="cov8" title="1"></span>
        }

        // 相対パスの計算
        <span class="cov8" title="1">relPath, err := filepath.Rel(fc.sourceDir, sourcePath)
        if err != nil </span><span class="cov0" title="0">{
                relPath = filepath.Base(sourcePath)
        }</span>

        // 進捗報告
        <span class="cov8" title="1">if fc.progressFunc != nil </span><span class="cov8" title="1">{
                select </span>{
                case fc.progressChan &lt;- relPath:<span class="cov8" title="1"></span>
                        // 正常に送信
                default:<span class="cov0" title="0"></span>
                        // チャンネルが閉じられているか、バッファが一杯
                }
        }

        // データベース内の既存ファイル情報を確認
        <span class="cov8" title="1">var fileInfo *database.FileInfo
        if fc.db != nil </span><span class="cov8" title="1">{
                fileInfo, err = fc.db.GetFile(relPath)
                if err != nil </span><span class="cov8" title="1">{
                        if fc.logger != nil </span><span class="cov0" title="0">{
                                if fc.logger.Verbose </span><span class="cov0" title="0">{
                                        fc.logger.Warn("データベース検索エラー: %v", err)
                                }</span>
                        }
                }
        }

        // ソースファイルの情報を取得
        <span class="cov8" title="1">sourceInfo, err := os.Stat(sourcePath)
        if err != nil </span><span class="cov8" title="1">{
                fc.stats.IncrementFailed()

                // データベースに記録
                if fc.db != nil </span><span class="cov0" title="0">{
                        errInfo := database.FileInfo{
                                Path:         relPath,
                                Status:       database.StatusFailed,
                                LastSyncTime: time.Now(),
                                LastError:    fmt.Sprintf("ソースファイル確認エラー: %v", err),
                        }
                        fc.db.AddFile(errInfo)
                }</span>

                // loggerでエラー出力
                <span class="cov8" title="1">if fc.logger != nil </span><span class="cov0" title="0">{
                        if fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Error("ソースファイル(%s)の確認エラー: %v", sourcePath, err)
                        }</span> else<span class="cov0" title="0"> {
                                fc.logger.Error("ファイル確認失敗: %s", relPath)
                        }</span>
                }

                <span class="cov8" title="1">return fmt.Errorf("ソースファイル(%s)の確認エラー: %w", sourcePath, err)</span>
        }

        // 検証モードの場合
        <span class="cov8" title="1">if fc.options.Mode == ModeVerify </span><span class="cov0" title="0">{
                return fc.verifyFile(sourcePath, destPath, relPath, sourceInfo)
        }</span>

        // 宛先ファイルの存在確認
        <span class="cov8" title="1">destInfo, err := os.Stat(destPath)
        if err == nil </span><span class="cov8" title="1">{
                // 宛先ファイルが存在する場合

                // 上書きが許可されていない場合はスキップ
                if !fc.options.OverwriteExisting </span><span class="cov8" title="1">{
                        fc.stats.IncrementSkipped(sourceInfo.Size())

                        // データベースに記録
                        if fc.db != nil </span><span class="cov0" title="0">{
                                skipInfo := database.FileInfo{
                                        Path:         relPath,
                                        Size:         sourceInfo.Size(),
                                        ModTime:      sourceInfo.ModTime(),
                                        Status:       database.StatusSkipped,
                                        LastSyncTime: time.Now(),
                                        LastError:    "宛先ファイルが既に存在します",
                                }
                                fc.db.AddFile(skipInfo)
                        }</span>

                        // loggerでスキップ情報を出力
                        <span class="cov8" title="1">if fc.logger != nil </span><span class="cov0" title="0">{
                                if fc.logger.Verbose </span><span class="cov0" title="0">{
                                        fc.logger.Info("ファイルをスキップ（上書き無効）: %s", relPath)
                                }</span>
                        }

                        <span class="cov8" title="1">return nil</span>
                }

                // サイズと更新時刻が同じ場合はスキップ
                <span class="cov0" title="0">if sourceInfo.Size() == destInfo.Size() &amp;&amp; sourceInfo.ModTime().Equal(destInfo.ModTime()) </span><span class="cov0" title="0">{
                        fc.stats.IncrementSkipped(sourceInfo.Size())

                        // データベースに記録
                        if fc.db != nil </span><span class="cov0" title="0">{
                                skipInfo := database.FileInfo{
                                        Path:         relPath,
                                        Size:         sourceInfo.Size(),
                                        ModTime:      sourceInfo.ModTime(),
                                        Status:       database.StatusSkipped,
                                        LastSyncTime: time.Now(),
                                }
                                fc.db.AddFile(skipInfo)
                        }</span>

                        // loggerでスキップ情報を出力
                        <span class="cov0" title="0">if fc.logger != nil </span><span class="cov0" title="0">{
                                if fc.logger.Verbose </span><span class="cov0" title="0">{
                                        fc.logger.Info("ファイルをスキップ（内容同一）: %s", relPath)
                                }</span>
                        }

                        // 検証と同時コピーモードの場合は検証も行う
                        <span class="cov0" title="0">if fc.options.Mode == ModeCopyAndVerify </span><span class="cov0" title="0">{
                                return fc.verifyFile(sourcePath, destPath, relPath, sourceInfo)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                }
        } else<span class="cov8" title="1"> if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                // 存在確認でエラーが発生した場合（存在しない以外のエラー）
                fc.stats.IncrementFailed()

                // データベースに記録
                if fc.db != nil </span><span class="cov0" title="0">{
                        errInfo := database.FileInfo{
                                Path:         relPath,
                                Size:         sourceInfo.Size(),
                                ModTime:      sourceInfo.ModTime(),
                                Status:       database.StatusFailed,
                                LastSyncTime: time.Now(),
                                LastError:    fmt.Sprintf("宛先ファイル確認エラー: %v", err),
                        }
                        fc.db.AddFile(errInfo)
                }</span>

                // loggerでエラー出力
                <span class="cov0" title="0">if fc.logger != nil </span><span class="cov0" title="0">{
                        if fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Error("宛先ファイル(%s)の確認エラー: %v", destPath, err)
                        }</span> else<span class="cov0" title="0"> {
                                fc.logger.Error("宛先ファイル確認失敗: %s", relPath)
                        }</span>
                }

                <span class="cov0" title="0">return fmt.Errorf("宛先ファイル(%s)の確認エラー: %w", destPath, err)</span>
        }

        // 宛先ディレクトリの作成
        <span class="cov8" title="1">if fc.options.CreateDirs </span><span class="cov8" title="1">{
                destDir := filepath.Dir(destPath)
                if err := os.MkdirAll(destDir, 0755); err != nil </span><span class="cov0" title="0">{
                        fc.stats.IncrementFailed()

                        // データベースに記録
                        if fc.db != nil </span><span class="cov0" title="0">{
                                errInfo := database.FileInfo{
                                        Path:         relPath,
                                        Size:         sourceInfo.Size(),
                                        ModTime:      sourceInfo.ModTime(),
                                        Status:       database.StatusFailed,
                                        LastSyncTime: time.Now(),
                                        LastError:    fmt.Sprintf("宛先ディレクトリ作成エラー: %v", err),
                                }
                                fc.db.AddFile(errInfo)
                        }</span>

                        // loggerでエラー出力
                        <span class="cov0" title="0">if fc.logger != nil </span><span class="cov0" title="0">{
                                if fc.logger.Verbose </span><span class="cov0" title="0">{
                                        fc.logger.Error("宛先ディレクトリ(%s)の作成エラー: %v", destDir, err)
                                }</span> else<span class="cov0" title="0"> {
                                        fc.logger.Error("ディレクトリ作成失敗: %s", relPath)
                                }</span>
                        }

                        <span class="cov0" title="0">return fmt.Errorf("宛先ディレクトリ(%s)の作成エラー: %w", destDir, err)</span>
                }
        }

        // ファイルのコピー（リトライロジック付き）
        <span class="cov8" title="1">var copyErr error
        for retry := 0; retry &lt;= fc.options.MaxRetries; retry++ </span><span class="cov8" title="1">{
                if retry &gt; 0 </span><span class="cov0" title="0">{
                        // リトライ前に遅延
                        time.Sleep(fc.options.RetryDelay)

                        // loggerでリトライ情報を出力
                        if fc.logger != nil </span><span class="cov0" title="0">{
                                if fc.logger.Verbose </span><span class="cov0" title="0">{
                                        fc.logger.Warn("ファイル '%s' のコピーをリトライします (%d/%d): エラー: %v", relPath, retry, fc.options.MaxRetries, copyErr)
                                }</span> else<span class="cov0" title="0"> {
                                        fc.logger.Warn("ファイル '%s' のコピーをリトライします (%d/%d)", relPath, retry, fc.options.MaxRetries)
                                }</span>
                        }
                }

                // ファイルのコピー
                <span class="cov8" title="1">copyErr = fc.doCopyFile(sourcePath, destPath, sourceInfo)
                if copyErr == nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        // すべてのリトライが失敗した場合
        <span class="cov8" title="1">if copyErr != nil </span><span class="cov0" title="0">{
                fc.stats.IncrementFailed()

                // データベースに記録
                if fc.db != nil </span><span class="cov0" title="0">{
                        failCount := 0
                        if fileInfo != nil </span><span class="cov0" title="0">{
                                failCount = fileInfo.FailCount + 1
                        }</span>

                        <span class="cov0" title="0">errInfo := database.FileInfo{
                                Path:         relPath,
                                Size:         sourceInfo.Size(),
                                ModTime:      sourceInfo.ModTime(),
                                Status:       database.StatusFailed,
                                FailCount:    failCount,
                                LastSyncTime: time.Now(),
                                LastError:    fmt.Sprintf("ファイルコピーエラー: %v", copyErr),
                        }
                        fc.db.AddFile(errInfo)</span>
                }

                // loggerでエラー出力
                <span class="cov0" title="0">if fc.logger != nil </span><span class="cov0" title="0">{
                        if fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Error("ファイル '%s' のコピーに失敗しました: %v", relPath, copyErr)
                        }</span> else<span class="cov0" title="0"> {
                                fc.logger.Error("コピー失敗: %s", relPath)
                        }</span>
                }

                <span class="cov0" title="0">return fmt.Errorf("ファイル '%s' のコピーに失敗しました: %w", relPath, copyErr)</span>
        }

        // コピー成功の記録
        <span class="cov8" title="1">fc.stats.IncrementCopied(sourceInfo.Size())

        // データベースに記録
        if fc.db != nil </span><span class="cov8" title="1">{
                successInfo := database.FileInfo{
                        Path:         relPath,
                        Size:         sourceInfo.Size(),
                        ModTime:      sourceInfo.ModTime(),
                        Status:       database.StatusSuccess,
                        LastSyncTime: time.Now(),
                }
                fc.db.AddFile(successInfo)
        }</span>

        // loggerで成功情報を出力
        <span class="cov8" title="1">if fc.logger != nil </span><span class="cov0" title="0">{
                if fc.logger.Verbose </span><span class="cov0" title="0">{
                        fc.logger.Info("ファイルコピー成功: %s (%d bytes)", relPath, sourceInfo.Size())
                }</span> else<span class="cov0" title="0"> {
                        fc.logger.Info("コピー成功: %s", relPath)
                }</span>
        }

        // 検証と同時コピーモードの場合は検証も行う
        <span class="cov8" title="1">if fc.options.Mode == ModeCopyAndVerify </span><span class="cov0" title="0">{
                return fc.verifyFile(sourcePath, destPath, relPath, sourceInfo)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// doCopyFile は実際のファイルコピー処理を行う
func (fc *FileCopier) doCopyFile(sourcePath, destPath string, sourceInfo os.FileInfo) error <span class="cov8" title="1">{
        // ソースファイルを開く
        sourceFile, err := os.Open(sourcePath)
        if err != nil </span><span class="cov8" title="1">{
                // loggerでエラー出力
                if fc.logger != nil &amp;&amp; fc.logger.Verbose </span><span class="cov0" title="0">{
                        fc.logger.Error("ソースファイル(%s)を開けません: %v", sourcePath, err)
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("ソースファイル(%s)を開けません: %w", sourcePath, err)</span>
        }
        <span class="cov8" title="1">defer sourceFile.Close()

        // 宛先ファイルを作成
        destFile, err := os.Create(destPath)
        if err != nil </span><span class="cov0" title="0">{
                // loggerでエラー出力
                if fc.logger != nil &amp;&amp; fc.logger.Verbose </span><span class="cov0" title="0">{
                        fc.logger.Error("宛先ファイル(%s)を作成できません: %v", destPath, err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("宛先ファイル(%s)を作成できません: %w", destPath, err)</span>
        }
        <span class="cov8" title="1">defer destFile.Close()

        // バッファを作成
        buffer := make([]byte, fc.options.BufferSize)

        // ファイルをコピー
        copiedBytes, err := io.CopyBuffer(destFile, sourceFile, buffer)
        if err != nil </span><span class="cov0" title="0">{
                // loggerでエラー出力
                if fc.logger != nil &amp;&amp; fc.logger.Verbose </span><span class="cov0" title="0">{
                        fc.logger.Error("ファイルコピーエラー: %s -&gt; %s: %v", sourcePath, destPath, err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("ファイルコピーエラー: %w", err)</span>
        }

        // コピーされたバイト数の確認
        <span class="cov8" title="1">if copiedBytes != sourceInfo.Size() </span><span class="cov0" title="0">{
                // loggerで警告出力
                if fc.logger != nil &amp;&amp; fc.logger.Verbose </span><span class="cov0" title="0">{
                        fc.logger.Warn("コピーされたバイト数が一致しません: 期待値=%d, 実際=%d", sourceInfo.Size(), copiedBytes)
                }</span>
        }

        // ファイルを閉じる（エラーチェック付き）
        <span class="cov8" title="1">if err = destFile.Close(); err != nil </span><span class="cov0" title="0">{
                // loggerでエラー出力
                if fc.logger != nil &amp;&amp; fc.logger.Verbose </span><span class="cov0" title="0">{
                        fc.logger.Error("宛先ファイル(%s)を閉じられません: %v", destPath, err)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("宛先ファイル(%s)を閉じられません: %w", destPath, err)</span>
        }

        // 更新日時の保持
        <span class="cov8" title="1">if fc.options.PreserveModTime </span><span class="cov8" title="1">{
                if err = os.Chtimes(destPath, time.Now(), sourceInfo.ModTime()); err != nil </span><span class="cov0" title="0">{
                        // loggerでエラー出力
                        if fc.logger != nil &amp;&amp; fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Error("更新日時の設定エラー: %s: %v", destPath, err)
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("更新日時の設定エラー: %w", err)</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// verifyFile はファイルのハッシュ検証を行う
func (fc *FileCopier) verifyFile(sourcePath, destPath, relPath string, sourceInfo os.FileInfo) error <span class="cov8" title="1">{
        // ハッシュ検証が無効の場合はスキップ
        if !fc.options.VerifyHash </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 宛先ファイルの存在確認
        <span class="cov8" title="1">if _, err := os.Stat(destPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                // データベースに記録
                if fc.db != nil </span><span class="cov0" title="0">{
                        errInfo := database.FileInfo{
                                Path:         relPath,
                                Size:         sourceInfo.Size(),
                                ModTime:      sourceInfo.ModTime(),
                                Status:       database.StatusMismatch,
                                LastSyncTime: time.Now(),
                                LastError:    "宛先ファイルが存在しません",
                        }
                        fc.db.AddFile(errInfo)
                }</span>

                // loggerでエラー出力
                <span class="cov8" title="1">if fc.logger != nil </span><span class="cov0" title="0">{
                        if fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Error("宛先ファイル(%s)が存在しません", destPath)
                        }</span> else<span class="cov0" title="0"> {
                                fc.logger.Error("検証失敗: %s (宛先ファイルなし)", relPath)
                        }</span>
                }

                <span class="cov8" title="1">return fmt.Errorf("宛先ファイル '%s' が存在しません", destPath)</span>
        }

        // ソースファイルのハッシュを計算
        <span class="cov8" title="1">sourceHash, err := fc.hasher.HashFile(sourcePath)
        if err != nil </span><span class="cov8" title="1">{
                // データベースに記録
                if fc.db != nil </span><span class="cov0" title="0">{
                        errInfo := database.FileInfo{
                                Path:         relPath,
                                Size:         sourceInfo.Size(),
                                ModTime:      sourceInfo.ModTime(),
                                Status:       database.StatusFailed,
                                LastSyncTime: time.Now(),
                                LastError:    fmt.Sprintf("ソースハッシュ計算エラー: %v", err),
                        }
                        fc.db.AddFile(errInfo)
                }</span>

                // loggerでエラー出力
                <span class="cov8" title="1">if fc.logger != nil </span><span class="cov0" title="0">{
                        if fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Error("ソースファイル(%s)のハッシュ計算エラー: %v", sourcePath, err)
                        }</span> else<span class="cov0" title="0"> {
                                fc.logger.Error("ハッシュ計算失敗: %s", relPath)
                        }</span>
                }

                <span class="cov8" title="1">return fmt.Errorf("ソースファイル(%s)のハッシュ計算エラー: %w", sourcePath, err)</span>
        }

        // 宛先ファイルのハッシュを計算
        <span class="cov8" title="1">destHash, err := fc.hasher.HashFile(destPath)
        if err != nil </span><span class="cov0" title="0">{
                // データベースに記録
                if fc.db != nil </span><span class="cov0" title="0">{
                        errInfo := database.FileInfo{
                                Path:         relPath,
                                Size:         sourceInfo.Size(),
                                ModTime:      sourceInfo.ModTime(),
                                Status:       database.StatusFailed,
                                LastSyncTime: time.Now(),
                                LastError:    fmt.Sprintf("宛先ハッシュ計算エラー: %v", err),
                        }
                        fc.db.AddFile(errInfo)
                }</span>

                // loggerでエラー出力
                <span class="cov0" title="0">if fc.logger != nil </span><span class="cov0" title="0">{
                        if fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Error("宛先ファイル(%s)のハッシュ計算エラー: %v", destPath, err)
                        }</span> else<span class="cov0" title="0"> {
                                fc.logger.Error("ハッシュ計算失敗: %s", relPath)
                        }</span>
                }

                <span class="cov0" title="0">return fmt.Errorf("宛先ファイル(%s)のハッシュ計算エラー: %w", destPath, err)</span>
        }

        // ハッシュ値をデータベースに記録
        <span class="cov8" title="1">if fc.db != nil </span><span class="cov0" title="0">{
                fc.db.UpdateFileHash(relPath, sourceHash, destHash)
        }</span>

        // ハッシュ値の比較
        <span class="cov8" title="1">if sourceHash != destHash </span><span class="cov8" title="1">{
                // データベースに記録
                if fc.db != nil </span><span class="cov0" title="0">{
                        errInfo := database.FileInfo{
                                Path:         relPath,
                                Size:         sourceInfo.Size(),
                                ModTime:      sourceInfo.ModTime(),
                                Status:       database.StatusMismatch,
                                SourceHash:   sourceHash,
                                DestHash:     destHash,
                                LastSyncTime: time.Now(),
                                LastError:    "ハッシュ値が一致しません",
                        }
                        fc.db.AddFile(errInfo)
                }</span>

                // loggerでエラー出力
                <span class="cov8" title="1">if fc.logger != nil </span><span class="cov0" title="0">{
                        if fc.logger.Verbose </span><span class="cov0" title="0">{
                                fc.logger.Error("ファイル '%s' のハッシュ値が一致しません (ソース: %s, 宛先: %s)", relPath, sourceHash, destHash)
                        }</span> else<span class="cov0" title="0"> {
                                fc.logger.Error("ハッシュ不一致: %s", relPath)
                        }</span>
                }

                <span class="cov8" title="1">return fmt.Errorf("ファイル '%s' のハッシュ値が一致しません (ソース: %s, 宛先: %s)", relPath, sourceHash, destHash)</span>
        }

        // 検証成功の記録
        <span class="cov8" title="1">if fc.db != nil </span><span class="cov0" title="0">{
                verifyInfo := database.FileInfo{
                        Path:         relPath,
                        Size:         sourceInfo.Size(),
                        ModTime:      sourceInfo.ModTime(),
                        Status:       database.StatusVerified,
                        SourceHash:   sourceHash,
                        DestHash:     destHash,
                        LastSyncTime: time.Now(),
                }
                fc.db.AddFile(verifyInfo)
        }</span>

        // loggerで成功情報を出力
        <span class="cov8" title="1">if fc.logger != nil </span><span class="cov0" title="0">{
                if fc.logger.Verbose </span><span class="cov0" title="0">{
                        fc.logger.Info("ファイル検証成功: %s (ハッシュ: %s)", relPath, sourceHash)
                }</span> else<span class="cov0" title="0"> {
                        fc.logger.Info("検証成功: %s", relPath)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// reportProgress は進捗報告を行うゴルーチン
func (fc *FileCopier) reportProgress() <span class="cov8" title="1">{
        ticker := time.NewTicker(fc.options.ProgressInterval)
        defer ticker.Stop()

        var currentFile string

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-fc.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case file, ok := &lt;-fc.progressChan:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">currentFile = file</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if fc.progressFunc != nil </span><span class="cov8" title="1">{
                                totalFiles, _, _ := fc.stats.GetProgressStats()
                                fc.progressFunc(
                                        fc.stats.GetCopiedCount()+fc.stats.GetSkippedCount(),
                                        totalFiles,
                                        currentFile,
                                )
                        }</span>
                }
        }
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
